// В теннисном турнире участвуют 2* игроков (1 ≤ п ≤ 18). Каждый теннисист имеет индивидуальный 
// числовой рейтинг. Чем больше рейтинг, тем выше мастерство игрока. Известно, что рейтинги всех игроков разные.
// Турнир проходит по олимпийской системе с выбываниями. После каждого тура проигравшие покидают турнир. 
// Таким образом, п-й тур является финалом.
// Организаторы формируют начальный список участников. В первом туре первый игрок списка играет со вторым, 
// третий с четвертым и т. д. В результате список сокращается вдвое. Во втором туре встречаются победители 
// первой и второй пар, третьей и четвертой и т. д. Далее все продолжается аналогично.
// Таким образом, начальный список и результаты матчей полностью
// определяют пары участников последующих встреч.
// Игроки получили стартовые номера в порядке убывания их рейтинга. Сильнейший игрок имеет номер 1, 
// второй по силе - номер 2 и т. д. Конечно, никому не хочется, чтобы сильные игроки встречались на ранних этапах. 
// Более того, по традиции проведения турниров фавориты играют сначала со слабейшими игроками. Поэтому в первом туре 
// запланированы матчи игроков с номерами 1 и 2", 2 и 2^ - 1, 3 и 2° - 2 и т. д. Решено подобный принцип распространить 
// и на последующие туры.
// Организаторы рассуждают так. Допустим, что в матчах всегда будут побеждать игроки с более высоким рейтингом. 
// Тогда во второй тур выйдут игроки с номерами 1, 2, ..., 2*. Желательно, чтобы далее встретились игроки 
// с номерами 1 и 21, 2 и 2*1 - 1, ..., 2-2 и 2гг + 1. Тогда в третий тур выйдут лучшие игроки с номерами 1, 2, ...., 2?. 
// При подобном течении турнира в каждый следующий тур будут попадать лучшие по рейтингу игроки предыдущего тура. Интрига 
// сохранится до конца турнира, а в финале окажутся первые два номера рейтинга.
// Помогите организаторам турнира сформировать начальный список игроков в соответствии с описанными пожеланиями.
// Ввод. В единственной строке находится значения п.
// Вывод. В единственной строке вывести через пробел 2^ номеров игроков, составляющих начальный список. В случае нескольких вариантов вывести любое допустимое решение.
// Visual Studio Code
// Гусев Сергей ПС-22

#include <iostream>
#include <fstream>
#include <vector>
#include <cmath>

using namespace std;

// Функция для генерации начального списка участников
void generateInitialList(int n, vector<int>& result) {
    int totalPlayers = 1 << n; // 2^n игроков
    vector<int> temp(totalPlayers);

    for (int i = 0; i < totalPlayers; ++i) {
        temp[i] = i + 1;
    }

    int half = totalPlayers / 2;
    for (int i = 0; i < half; ++i) {
        result.push_back(temp[i]);
        result.push_back(temp[totalPlayers - 1 - i]);
    }
}

// Функция для симуляции турнира и определения победителя
void simulateTournament(vector<int>& players, ofstream& outputFile) {
    int round = 1;
    while (players.size() > 1) {
        outputFile << "Round " << round << ":";
        for (size_t i = 0; i < players.size(); ++i) {
            if (i > 0) outputFile << " ";
            outputFile << players[i];
        }
        outputFile << endl;

        vector<int> nextRound;
        for (size_t i = 0; i < players.size(); i += 2) {
            nextRound.push_back(players[i]);  // Более высокий рейтинг побеждает
        }
        players = nextRound;
        round++;
    }

    // Последний раунд
    outputFile << "Round " << round << ": " << players[0] << endl;
}

int main() {
    ifstream inputFile("input.txt");
    ofstream outputFile("output.txt");

    if (!inputFile.is_open() || !outputFile.is_open()) {
        cerr << "Error opening file!" << endl;
        return 1;
    }

    int n;
    inputFile >> n;
    vector<int> result;

    generateInitialList(n, result);

    // Запись начального списка в файл
    outputFile << "Initial list: ";
    for (int i = 0; i < result.size(); ++i) {
        if (i > 0) outputFile << " ";
        outputFile << result[i];
    }
    outputFile << endl;

    // Симуляция турнира и вывод каждого раунда
    simulateTournament(result, outputFile);

    inputFile.close();
    outputFile.close();

    return 0;
}
